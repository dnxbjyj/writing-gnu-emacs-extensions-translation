
---
> 英文版PDF位置：P41

# 第3章：组合命令
在本章将会讲到：
- 一个痛点
- 一种方案
- 产生解决方案

本章将会探讨通过在一个命令中保存信息、在另一个命令中获取这个信息，从而实现让多个不同的命令协同工作。在命令之间共享信息最简单的方式就是创建一个变量并把信息保存在里面，我们在本章将会尝试使用这种方式。例如，我们可以在变量中保存当前缓冲区的位置信息，从而在之后的命令中可以使用这个位置信息。当然我们也会学习一些更为复杂的方式来保存状态、标记和符号属性等信息。我们在最后将会综合上述技术来解决一个痛点：写一些函数来保存、处理缓冲区和窗口的信息，从而实现撤销滚动窗口操作的目的。

## 一个痛点
设想一个场景：
> 你正在专心致志地编写着复杂的Lisp代码，你专注于脑海中不同的概念之间脆弱的联系、并修改着它们，同时注意着屏幕上表示它们的那些符号。你正在思考着特别关键的部分，而这时你注意到了左边几个字符处的拼写错误。你准备按`C-b C-b C-b`快捷键回退到那里然后改正这个错误，但是相反——糟糕的是——你错误地按下了`C-v C-v C-v`，滚动了屏幕三次，远离了你刚刚正在编辑的位置十万八千里。当你想尝试搞清楚出错之前光标是在哪个位置时，你大脑中的上下文已经被毁坏了，并且已经忘记了你刚刚在编辑的是什么。这个时候你滚动屏幕，或搜索，或循环切换标记环（mark-ring）、回退列表（undo-list）尝试回到你出错前所在的位置，你已经忘记了你一开始想要修改的拼写错误是什么，并且后来你的代码中可能出现了一个bug，你需要花费几个小时才能找到。

Emacs对于解决上述场景的问题无能为力，这使得在你的文档中很容易跳转错位置，并且很难回到出错之前的位置。虽然Emacs有扩展的撤销机制，但是只能允许你撤销修改，而不能撤销简单的位置跳转操作。

---
> 英文版PDF位置：P42

## 一种方案
设想一下，假如我们可以修改`C-v`快捷键（即`scroll-up`命令）的行为，使得在按下这个快捷键时，Emacs会想："用户可能是错误地按下了`C-v`快捷键，所以也许我应该记录一些撤销信息，以备用户不时之需"。那么我们其实可以写另一个函数：`unscroll`，这个函数可以撤销最后一次滚动屏幕的操作。这样的话，不小心跳转到错误的位置之后就不会中断你大脑中的上下午，因为你只需要记住`unscroll`命令的快捷键即可。

实际上，这还不够好。如果你连续按了多次`C-v`快捷键，调用`unscroll`函数时撤销的应该是所有这几次操作，而不仅仅是最后一次。这意味着在连续多次按`C-v`的情况下，应该只记录第一次的位置。我们应该怎样实现呢？在我们的`C-v`代码中，在我们记录开始位置之前，我们必须搞清楚以下两件事之一：(a)下一个命令将会是`scroll-up`；(b)前一个命令不是`scroll-up`。很显然，(a)是不可能提前知晓的，因为我们无法预知未来。幸运的是，搞清楚(b)却是非常简单的：Emacs维护了一个名为`last-command`的变量，就是为了记录前一个命令是是什么。这个变量是我们将会使用到的第一个用于在前后两个命令之间传递信息的机制。

那么现在剩下的唯一一个问题就是：我们如何才能把记录起始位置这段额外的代码附着到`scroll-up`命令上呢？Emacs的`advice`机制就是专门为这一目的而设计的，你所定义的一条`advice`可以在其修饰的函数之前或之后运行。在当前的场景中，我们需要一个前置的`advice`，因为我们只是需要在`scroll-up`命令之前来运行这个`advice`从而记录下起始位置。

## 声明变量
我们将从定义一个全局变量开始，这个变量的名称为`unscroll-to`，它保存了一些撤销时所需的缓冲区位置信息，也就是我们将要写的`unscroll`命令需要移动到的位置。我们使用`defvar`关键字来声明一个变量：
``` emacs-lisp
(defvar unscroll-to nil "Text position for next call to 'unscroll'.")
```
虽然全局变量不需要声明，但是使用`defvar`声明变量有这样一些好处：
- 使用`defvar`声明一个变量时可以为它写一个变量文档注释，和使用`defun`定义一个函数时可以写一个函数文档注释是一样的。
- 可以为变量设置一个默认值，在上面的例子里面，`unscroll-to`这个变量的默认值是`nil`。 

---
> 英文版PDF位置：P43
